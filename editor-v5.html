let newLines = [];
let pathBuffer = [];
let firstPoint = null;

lines.forEach(line => {
  const xMatch = line.match(/X([\d\.\-]+)/);
  const yMatch = line.match(/Y([\d\.\-]+)/);
  const zMatch = line.match(/Z([\d\.\-]+)/);
  const eMatch = line.match(/E([\d\.\-]+)/);

  // Siempre guardar la línea original
  newLines.push(line);

  if (xMatch && yMatch) {
    const x = parseFloat(xMatch[1]);
    const y = parseFloat(yMatch[1]);

    if (!firstPoint) {
      firstPoint = {x, y};
    }

    pathBuffer.push(line);

    const dx = x - firstPoint.x;
    const dy = y - firstPoint.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // Detectar cierre de vuelta
    if (dist < 0.5 && pathBuffer.length > 50) {
      // Duplicar la vuelta con Z desplazado
      pathBuffer.forEach(l => {
        let dupLine = l;
        if (zMatch) {
          const zVal = parseFloat(zMatch[1]);
          dupLine = dupLine.replace(/Z([\d\.\-]+)/, "Z" + (zVal + 0.1).toFixed(3));
        }
        if (eMatch) {
          const eVal = parseFloat(eMatch[1]);
          dupLine = dupLine.replace(/E([\d\.\-]+)/, "E" + (eVal * 2).toFixed(5));
        }
        newLines.push(dupLine);
      });

      // Reiniciar para la próxima vuelta
      pathBuffer = [];
      firstPoint = null;
    }
  }
});
